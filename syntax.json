{"builtin":[{"description":"a boolean type (true | false)","token":"bool"},{"description":"a string type","token":"str"},{"description":"signed 8-bit integer","token":"i8"},{"description":"signed 16-bit integer","token":"i16"},{"description":"signed 32-bit integer","token":"i32"},{"description":"signed 64-bit integer","token":"i64"},{"description":"unsigned 8-bit integer","token":"u8"},{"description":"unsigned 16-bit integer","token":"u16"},{"description":"unsigned 32-bit integer","token":"u32"},{"description":"unsigned 64-bit integer","token":"u64"},{"description":"a signed 16-bit floating point number","token":"f16"},{"description":"a signed 32-bit floating point number","token":"f32"},{"description":"a signed 64-bit floating point number","token":"f64"},{"description":"a complex number with real and imaginary parts.","token":"complex"},{"description":"a [iso 8601](https://en.wikipedia.org/wiki/ISO_8601) compliant datetime providing timezone.","token":"datetime"},{"description":"a unit type (0 size)","token":"never"},{"description":"a binary stream. this is distinct from u8[], where we may have language specific types to utilize if you intend to manipulate octal streams.","token":"binary"}],"keywords":[{"description":"keyword `schema`. used to reference types within the same package.","token":"schema"},{"description":"keyword `namespace`. should precede an identifier.","token":"namespace"},{"description":"keyword `use`. should precede a namespace to be used.","token":"use"},{"description":"keyword `struct`. used to declare a struct.","token":"struct"},{"description":"keyword `enum`. used to declare an enumeration.","token":"enum"},{"description":"keyword `type`. used to declare a type alias.","token":"type"},{"description":"keyword `oneof`. used to declare a sequence of type variants or named enumeration of types.","token":"oneof"},{"description":"keyword `error`. used to declare an error type.","token":"error"},{"description":"keyword `operation`. used to declare an operation.","token":"operation"}],"tokens":[{"description":"brackets are paired between spans. brackets are permitted in array types, meta fields, and spanned namespace declarations.","token":"[]"},{"description":"braces are paired between spans. braces are permitted in: named structs, anonymous structs, enums, oneofs, and errors","token":"{}"},{"description":"parentheses are paired between spans. parentheses are permitted in: meta fields, types, operations, and errors","token":"()"},{"description":"amp tokens are supported in union types to separate type variants.","token":"&"},{"description":"scope resolution operators are used to access named declarations of external namespaces, with no whitespace, and no trailing operator.","token":"::"},{"description":"semicolons are used to terminate a top-level declaration (item).","token":";"},{"description":"colons are used to separate a field from its type in arguments. there should be no proceeding whitespace between the proceeding `ident`, with a following space before the subsequent type.","token":":"},{"description":"commas are used to separate fields, enum and error variants, and arguments. trailing commas are permitted.","token":","},{"description":"used to indicate an optional type.","token":"?"},{"description":"equals is used to declare a named type, or provide a static value to an enum member.","token":"="},{"description":"pound tokens are used in meta. e.g. `#[...]`","token":"#"},{"description":"bang tokens are used to set meta as inner meta, or declare a return type may raise an error. e.g. `-> i32!`.","token":"!"},{"description":"pipe tokens are supported in oneof types to separate type variants.","token":"\\|"},{"description":"used to start a single-line comment, terminated by a new line.","token":"//"},{"description":"used to start a multi-line comment, terminated by `*/`","token":"/*"},{"description":"used to end a multi-line comment","token":"*/"}]}
